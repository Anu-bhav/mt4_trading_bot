# backtesting/strategy_adapter.py
import logging

import pandas as pd
from backtesting import Strategy


class StrategyAdapter(Strategy):
    """
    An adapter that allows any strategy written for our live framework
    to be backtested using the backtesting.py library without modification.
    """

    # This will be populated by the backtest engine before running.
    user_strategy: object = None

    def init(self):
        """
        The `init` method is called once by backtesting.py at the start.
        """
        logging.info("StrategyAdapter initialized.")
        if not self.user_strategy:
            raise ValueError("User strategy has not been set in the adapter. This must be done before running the backtest.")

        # Initialize the user strategy's internal state
        self.user_strategy.reset()

    def next(self):
        """
        The `next` method is called by backtesting.py for each bar.
        This is the core of the translation logic.
        """
        # 1. Get the data from the backtester. It has PascalCase columns.
        original_df = self.data.df.iloc[: len(self.data)]

        # 2. --- THE FIX: Create a standardized, lowercase copy for our strategy ---
        strategy_df = original_df.copy()
        strategy_df.columns = [col.lower() for col in strategy_df.columns]

        # 3. GET SIGNAL using the standardized DataFrame
        signal = self.user_strategy.get_signal(strategy_df)
        if signal is None:
            logging.warning("No signal generated by the strategy.")
            return

        # 3. TRANSLATE SIGNAL: Convert the simple 'BUY'/'SELL'/'HOLD' signal
        # into execution commands that backtesting.py understands.
        if signal == "BUY" and not self.position.is_long:
            if self.position.is_short:
                self.position.close()
            self.buy()

        elif signal == "SELL" and not self.position.is_short:
            if self.position.is_long:
                self.position.close()
            self.sell()
